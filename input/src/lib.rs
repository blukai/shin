use std::hash::{Hash, Hasher};

use nohash::{NoHash, NoHashMap, NoHashSet};

// pointer

#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PointerButton {
    /// equivalent to left mouse button
    Primary,
    /// equivalent to right mouse button
    Secondary,
    /// equivalent to middle mouse button
    Tertiary,
}

impl Hash for PointerButton {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_u8(*self as u8);
    }
}

impl NoHash for PointerButton {}

impl PointerButton {
    /// NOTE: this is useful for calling InputState's all_just_released method for example.
    pub fn all() -> [Self; 3] {
        use PointerButton::*;
        [Primary, Secondary, Tertiary]
    }
}

#[derive(Debug)]
pub enum PointerEvent {
    Motion { position: (f64, f64) },
    Press { button: PointerButton },
    Release { button: PointerButton },
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CursorShape {
    Default,
    Pointer,
}

// keyboard

/// Scancode is a hardware-generated code that corresponds to the physical key pressed on the
/// keyboard. It represents the physical location of the key regardless of the keyboard layout.
/// Scancodes are consistent across different keyboard layouts and are generated by the keyboard
/// hardware itself. For example, pressing the key in the position of "Q" on a QWERTY keyboard will
/// generate the same scancode even if the keyboard layout is AZERTY or Dvorak
///
/// (c) ai
#[repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Scancode {
    Esc,
    Backspace,
    W,
    A,
    S,
    D,
    ShiftLeft,
    ShiftRight,
    ArrowUp,
    ArrowLeft,
    ArrowRight,
    ArrowDown,
    Delete,
}

impl Hash for Scancode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_u32(*self as u32);
    }
}

impl NoHash for Scancode {}

/// Keycode is a code assigned by the operating system or software that represents the symbol or
/// character mapped to the key pressed, taking into account the current keyboard layout. For
/// example, pressing the same physical key might generate a different keycode on an AZERTY
/// keyboard compared to a QWERTY keyboard because the symbol mapped to that key differs
///
/// (c) ai
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Keycode {
    Char(char),
    Unhandled,
}

impl Hash for Keycode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            Self::Char(ch) => state.write_u32(*ch as u32),
            Self::Unhandled => {
                // NOTE: according to https://www.rfc-editor.org/rfc/rfc3629 In UTF-8, characters
                // from the U+0000..U+10FFFF. 0x10FFFF = 1114111 (21 bits)
                state.write_u32(u32::MAX)
            }
        }
    }
}

impl NoHash for Keycode {}

#[derive(Debug, PartialEq)]
pub enum KeyboardEvent {
    Press {
        scancode: Scancode,
        keycode: Keycode,
        /// true if this is a key repeat
        repeat: bool,
    },
    Release {
        scancode: Scancode,
        keycode: Keycode,
    },
}

// states

// NOTE: this is inspired by bevy (or stolen if you will). input handling is kind of nice there.
//
// NOTE: bevy also has just_pressed and just_released - those don't really do the thing because
// there can be a situation when key is pressed in a really quick succession with no frame in
// between -> this wil result in key-skip.
#[derive(Debug)]
pub struct ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    pressed: NoHashSet<B>,
    just_pressed: NoHashSet<B>,
    just_released: NoHashSet<B>,
}

impl<B> Default for ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    fn default() -> Self {
        Self {
            pressed: NoHashSet::default(),
            just_pressed: NoHashSet::default(),
            just_released: NoHashSet::default(),
        }
    }
}

impl<B> ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    pub fn press(&mut self, button: B) {
        self.pressed.insert(button);
        self.just_pressed.insert(button);
    }

    pub fn release(&mut self, button: B) {
        self.pressed.remove(&button);
        self.just_released.insert(button);
    }

    pub fn clear(&mut self) {
        self.just_pressed.clear();
        self.just_released.clear();
    }

    // pressed

    pub fn pressed(&self, button: B) -> bool {
        self.pressed.contains(&button)
    }

    pub fn any_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.pressed(button))
    }

    pub fn all_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.pressed(button))
    }

    pub fn iter_pressed(&self) -> impl Iterator<Item = B> {
        self.pressed.iter().copied()
    }

    // just pressed

    pub fn just_pressed(&self, button: B) -> bool {
        self.just_pressed.contains(&button)
    }

    pub fn any_just_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.just_pressed(button))
    }

    pub fn all_just_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.just_pressed(button))
    }

    pub fn iter_just_pressed(&self) -> impl Iterator<Item = B> {
        self.just_pressed.iter().copied()
    }

    // just released

    pub fn just_released(&self, button: B) -> bool {
        self.just_released.contains(&button)
    }

    pub fn any_just_released(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.just_released(button))
    }

    pub fn all_just_released(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.just_released(button))
    }

    pub fn iter_just_released(&self) -> impl Iterator<Item = B> {
        self.just_released.iter().copied()
    }
}

#[derive(Debug, Default)]
pub struct PointerState {
    pub position: (f64, f64),
    pub delta: (f64, f64),
    pub buttons: ButtonInput<PointerButton>,
    // NOTE: this is currently unused, but the plan is to use it for text selection / dragging.
    pub press_origins: NoHashMap<PointerButton, (f64, f64)>,
}

impl PointerState {
    pub fn handle_event(&mut self, ev: PointerEvent) {
        use PointerEvent::*;
        match ev {
            Motion { position: next } => {
                let prev = self.position;
                self.delta = (next.0 - prev.0, next.1 - prev.1);
                self.position = next;
            }
            Press { button } => {
                self.buttons.press(button);
                self.press_origins.insert(button, self.position);
            }
            Release { button } => {
                self.buttons.release(button);
                self.press_origins.remove(&button);
            }
        }
    }
}

#[derive(Debug, Default)]
pub struct KeyboardState {
    pub scancodes: ButtonInput<Scancode>,
    pub keycodes: ButtonInput<Keycode>,
}

impl KeyboardState {
    pub fn handle_event(&mut self, ev: KeyboardEvent) {
        use KeyboardEvent::*;
        match ev {
            Press {
                scancode, keycode, ..
            } => {
                self.scancodes.press(scancode);
                self.keycodes.press(keycode);
            }
            Release { scancode, keycode } => {
                self.scancodes.release(scancode);
                self.keycodes.release(keycode);
            }
        }
    }
}

#[derive(Debug, Default)]
pub struct State {
    pub pointer: PointerState,
    pub keyboard: KeyboardState,
}

impl State {
    pub fn end_frame(&mut self) {
        self.pointer.buttons.clear();

        self.keyboard.scancodes.clear();
        self.keyboard.keycodes.clear();
    }
}
