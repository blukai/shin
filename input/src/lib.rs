use std::hash::{Hash, Hasher};

use nohash::{NoHash, NoHashMap};

// pointer
// ----

#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PointerButton {
    /// equivalent to left mouse button
    Primary,
    /// equivalent to right mouse button
    Secondary,
    /// equivalent to middle mouse button
    Tertiary,
}

impl Hash for PointerButton {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_u8(*self as u8);
    }
}

impl NoHash for PointerButton {}

impl PointerButton {
    /// NOTE: this is useful for calling InputState's all_just_pressed/all_just_released method for
    /// example.
    pub fn all() -> [Self; 3] {
        use PointerButton::*;
        [Primary, Secondary, Tertiary]
    }
}

#[derive(Debug, Clone)]
pub enum PointerEvent {
    Motion { position: (f64, f64) },
    Press { button: PointerButton },
    Release { button: PointerButton },
}

#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CursorShape {
    Default,
    Pointer,
    Text,
}

// keyboard
// ----

/// Scancode is a hardware-generated code that corresponds to the physical key pressed on the
/// keyboard. It represents the physical location of the key regardless of the keyboard layout.
/// Scancodes are consistent across different keyboard layouts and are generated by the keyboard
/// hardware itself. For example, pressing the key in the position of "Q" on a QWERTY keyboard will
/// generate the same scancode even if the keyboard layout is AZERTY or Dvorak
///   - llm
///
/// https://github.com/torvalds/linux/blob/231825b2e1ff6ba799c5eaf396d3ab2354e37c6b/include/uapi/linux/input-event-codes.h#L76
#[repr(u16)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[rustfmt::skip]
pub enum Scancode {
    Reserved,               // KEY_RESERVED          0
    Esc,                    // KEY_ESC               1
    Num1,                   // KEY_1                 2
    Num2,                   // KEY_2                 3
    Num3,                   // KEY_3                 4
    Num4,                   // KEY_4                 5
    Num5,                   // KEY_5                 6
    Num6,                   // KEY_6                 7
    Num7,                   // KEY_7                 8
    Num8,                   // KEY_8                 9
    Num9,                   // KEY_9                 10
    Num0,                   // KEY_0                 11
    Minus,                  // KEY_MINUS             12
    Equal,                  // KEY_EQUAL             13
    Backspace,              // KEY_BACKSPACE         14
    Tab,                    // KEY_TAB               15
    Q,                      // KEY_Q                 16
    W,                      // KEY_W                 17
    E,                      // KEY_E                 18
    R,                      // KEY_R                 19
    T,                      // KEY_T                 20
    Y,                      // KEY_Y                 21
    U,                      // KEY_U                 22
    I,                      // KEY_I                 23
    O,                      // KEY_O                 24
    P,                      // KEY_P                 25
    BraceLeft,              // KEY_LEFTBRACE         26 /* [ */
    BraceRight,             // KEY_RIGHTBRACE        27 /* ] */
    Enter,                  // KEY_ENTER             28
    CtrlLeft,               // KEY_LEFTCTRL          29
    A,                      // KEY_A                 30
    S,                      // KEY_S                 31
    D,                      // KEY_D                 32
    F,                      // KEY_F                 33
    G,                      // KEY_G                 34
    H,                      // KEY_H                 35
    J,                      // KEY_J                 36
    K,                      // KEY_K                 37
    L,                      // KEY_L                 38
    Semicolon,              // KEY_SEMICOLON         39
    Apostrophe,             // KEY_APOSTROPHE        40
    Grave,                  // KEY_GRAVE             41
    ShiftLeft,              // KEY_LEFTSHIFT         42
    Backslash,              // KEY_BACKSLASH         43
    Z,                      // KEY_Z                 44
    X,                      // KEY_X                 45
    C,                      // KEY_C                 46
    V,                      // KEY_V                 47
    B,                      // KEY_B                 48
    N,                      // KEY_N                 49
    M,                      // KEY_M                 50
    Comma,                  // KEY_COMMA             51
    Dot,                    // KEY_DOT               52
    Slash,                  // KEY_SLASH             53
    ShiftRight,             // KEY_RIGHTSHIFT        54
    // KPAsterisk,          // KEY_KPASTERISK        55
    AltLeft,                // KEY_LEFTALT           56
    Space,                  // KEY_SPACE             57
    CapsLock,               // KEY_CAPSLOCK          58
    // F1,                  // KEY_F1                59
    // F2,                  // KEY_F2                60
    // F3,                  // KEY_F3                61
    // F4,                  // KEY_F4                62
    // F5,                  // KEY_F5                63
    // F6,                  // KEY_F6                64
    // F7,                  // KEY_F7                65
    // F8,                  // KEY_F8                66
    // F9,                  // KEY_F9                67
    // F10,                 // KEY_F10               68
    NumLock,                // KEY_NUMLOCK           69
    ScrollLock,             // KEY_SCROLLLOCK        70
    // KP7,                 // KEY_KP7               71
    // KP8,                 // KEY_KP8               72
    // KP9,                 // KEY_KP9               73
    // KPMinus,             // KEY_KPMINUS           74
    // KP4,                 // KEY_KP4               75
    // KP5,                 // KEY_KP5               76
    // KP6,                 // KEY_KP6               77
    // KPPlus,              // KEY_KPPLUS            78
    // KP1,                 // KEY_KP1               79
    // KP2,                 // KEY_KP2               80
    // KP3,                 // KEY_KP3               81
    // KP0,                 // KEY_KP0               82
    // KPDOT,               // KEY_KPDOT             83
    // _,
    // ZENKAKUHANKAKU,      // KEY_ZENKAKUHANKAKU    85
    // 102ND,               // KEY_102ND             86
    // F11,                 // KEY_F11               87
    // F12,                 // KEY_F12               88
    // RO,                  // KEY_RO                89
    // KATAKANA,            // KEY_KATAKANA          90
    // HIRAGANA,            // KEY_HIRAGANA          91
    // HENKAN,              // KEY_HENKAN            92
    // KATAKANAHIRAGANA,    // KEY_KATAKANAHIRAGANA  93
    // MUHENKAN,            // KEY_MUHENKAN          94
    // KPJPCOMMA,           // KEY_KPJPCOMMA         95
    // KPEnter,             // KEY_KPENTER           96
    CtrlRight,              // KEY_RIGHTCTRL         97
    // KPSlash,             // KEY_KPSLASH           98
    // SYSRQ,               // KEY_SYSRQ             99
    AltRight,               // KEY_RIGHTALT          100
    // LINEFEED,            // KEY_LINEFEED          101
    Home,                   // KEY_HOME              102
    ArrowUp,                // KEY_UP                103
    PageUp,                 // KEY_PAGEUP            104
    ArrowLeft,              // KEY_LEFT              105
    ArrowRight,             // KEY_RIGHT             106
    End,                    // KEY_END               107
    ArrowDown,              // KEY_DOWN              108
    PageDown,               // KEY_PAGEDOWN          109
    Insert,                 // KEY_INSERT            110
    Delete,                 // KEY_DELETE            111
    // MACRO,               // KEY_MACRO             112
    // MUTE,                // KEY_MUTE              113
    // VOLUMEDOWN,          // KEY_VOLUMEDOWN        114
    // VOLUMEUP,            // KEY_VOLUMEUP          115
    // POWER,               // KEY_POWER             116 /* SC System Power Down */
    // KPEqual,             // KEY_KPEQUAL           117
    // KPPLUSMINUS,         // KEY_KPPLUSMINUS       118
    // PAUSE,               // KEY_PAUSE             119
    // SCALE,               // KEY_SCALE             120 /* AL Compiz Scale (Expose) */
}

impl Hash for Scancode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_u32(*self as u32);
    }
}

impl NoHash for Scancode {}

/// Keycode is a code assigned by the operating system or software that represents the symbol or
/// character mapped to the key pressed, taking into account the current keyboard layout. For
/// example, pressing the same physical key might generate a different keycode on an AZERTY
/// keyboard compared to a QWERTY keyboard because the symbol mapped to that key differs
///   - llm
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Keycode {
    Char(char),
    Unhandled,
    // TODO: consider mapping scancode to keycode somehow to respect keyboard layouts. and maybe
    // don't operate on scancodes at all?
}

impl Hash for Keycode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            Self::Char(ch) => state.write_u32(*ch as u32),
            Self::Unhandled => {
                // NOTE: according to https://www.rfc-editor.org/rfc/rfc3629 In UTF-8, characters
                // from the U+0000..U+10FFFF. 0x10FFFF = 1114111 (21 bits)
                state.write_u32(u32::MAX)
            }
        }
    }
}

impl NoHash for Keycode {}

// TODO: might want to implement bitwise op traits for Keymods.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub struct Keymods(u16);

impl Keymods {
    pub const CTRL_LEFT: u16 = 1 << 0;
    pub const CTRL_RIGHT: u16 = 1 << 1;
    pub const SHIFT_LEFT: u16 = 1 << 2;
    pub const SHIFT_RIGHT: u16 = 1 << 3;
    pub const ALT_LEFT: u16 = 1 << 4;
    pub const ALT_RIGHT: u16 = 1 << 5;

    pub const CTRL: u16 = Self::CTRL_LEFT | Self::CTRL_RIGHT;
    pub const SHIFT: u16 = Self::SHIFT_LEFT | Self::SHIFT_RIGHT;
    pub const ALT: u16 = Self::ALT_LEFT | Self::ALT_RIGHT;

    pub fn try_from_scancode(scancode: Scancode) -> Option<Self> {
        match scancode {
            Scancode::CtrlLeft => Some(Self(Self::CTRL_LEFT)),
            Scancode::CtrlRight => Some(Self(Self::CTRL_RIGHT)),
            Scancode::ShiftLeft => Some(Self(Self::SHIFT_LEFT)),
            Scancode::ShiftRight => Some(Self(Self::SHIFT_RIGHT)),
            Scancode::AltLeft => Some(Self(Self::ALT_LEFT)),
            Scancode::AltRight => Some(Self(Self::ALT_RIGHT)),
            _ => None,
        }
    }

    // TODO: would i ever want to look for just either left or right mod but not both?

    pub fn ctrl(&self) -> bool {
        self.0 & Self::CTRL != 0
    }

    pub fn shift(&self) -> bool {
        self.0 & Self::SHIFT != 0
    }

    pub fn alt(&self) -> bool {
        self.0 & Self::ALT != 0
    }
}

#[derive(Debug, Clone)]
pub enum KeyboardEvent {
    Press {
        scancode: Scancode,
        keycode: Keycode,
        /// true if this is a key repeat
        repeat: bool,
    },
    Release {
        scancode: Scancode,
        keycode: Keycode,
    },
}

// states
// ----

// TODO: might want to implement bitwise op traits for ButtonStates.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub struct ButtonStates(u8);

impl ButtonStates {
    pub const JUST_PRESSED: u8 = 1 << 0;
    pub const JUST_RELEASED: u8 = 1 << 1;
    pub const DOWN: u8 = 1 << 2;
    pub const REPEAT: u8 = 1 << 3;
}

// NOTE: this is inspired by bevy's ButtonInput, but different!
#[derive(Debug)]
pub struct ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    states: NoHashMap<B, ButtonStates>,
}

// @BlindDerive
impl<B> Default for ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    fn default() -> Self {
        Self {
            states: NoHashMap::default(),
        }
    }
}

impl<B> ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    pub fn end_frame(&mut self) {
        self.states.values_mut().for_each(|state| {
            state.0 &= !ButtonStates::JUST_PRESSED;
            state.0 &= !ButtonStates::JUST_RELEASED;
            state.0 &= !ButtonStates::REPEAT;
        });
    }

    // ----

    pub fn press(&mut self, button: B, repeat: bool) {
        let state = self.states.entry(button).or_insert(ButtonStates(0));
        state.0 = ButtonStates::DOWN
            | if repeat {
                ButtonStates::REPEAT
            } else {
                ButtonStates::JUST_PRESSED
            };
    }

    pub fn release(&mut self, button: B) {
        let state = self.states.entry(button).or_insert(ButtonStates(0));
        state.0 = ButtonStates::JUST_RELEASED;
    }

    // just pressed

    pub fn just_pressed(&self, button: B) -> bool {
        self.states
            .get(&button)
            .is_some_and(|state| state.0 & ButtonStates::JUST_PRESSED != 0)
    }

    pub fn any_just_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.just_pressed(button))
    }

    pub fn all_just_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.just_pressed(button))
    }

    pub fn iter_just_pressed(&self) -> impl Iterator<Item = B> {
        self.states.iter().filter_map(|(button, state)| {
            (state.0 & ButtonStates::JUST_PRESSED != 0).then_some(*button)
        })
    }

    // just released

    pub fn just_released(&self, button: B) -> bool {
        self.states
            .get(&button)
            .is_some_and(|state| state.0 & ButtonStates::JUST_RELEASED != 0)
    }

    pub fn any_just_released(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.just_released(button))
    }

    pub fn all_just_released(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.just_released(button))
    }

    pub fn iter_just_released(&self) -> impl Iterator<Item = B> {
        self.states.iter().filter_map(|(button, state)| {
            (state.0 & ButtonStates::JUST_RELEASED != 0).then_some(*button)
        })
    }

    // down

    pub fn down(&self, button: B) -> bool {
        self.states
            .get(&button)
            .is_some_and(|state| state.0 & ButtonStates::DOWN != 0)
    }

    pub fn any_down(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.down(button))
    }

    pub fn all_down(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.down(button))
    }

    pub fn iter_down(&self) -> impl Iterator<Item = B> {
        self.states
            .iter()
            .filter_map(|(button, state)| (state.0 & ButtonStates::DOWN != 0).then_some(*button))
    }

    // repeat

    pub fn repeated(&self, button: B) -> bool {
        self.states
            .get(&button)
            .is_some_and(|state| state.0 & ButtonStates::REPEAT != 0)
    }

    pub fn any_repeated(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.repeated(button))
    }

    pub fn all_repeated(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.repeated(button))
    }

    pub fn iter_repeated(&self) -> impl Iterator<Item = B> {
        self.states
            .iter()
            .filter_map(|(button, state)| (state.0 & ButtonStates::REPEAT != 0).then_some(*button))
    }
}

#[derive(Debug, Default)]
pub struct PointerState {
    pub position: (f64, f64),
    pub delta: (f64, f64),
    pub buttons: ButtonInput<PointerButton>,
    pub press_origins: NoHashMap<PointerButton, (f64, f64)>,
}

impl PointerState {
    #[inline]
    pub fn handle_event(&mut self, ev: PointerEvent) {
        use PointerEvent::*;
        match ev {
            Motion { position: next } => {
                let prev = self.position;
                self.delta = (next.0 - prev.0, next.1 - prev.1);
                self.position = next;
            }
            Press { button } => {
                self.buttons.press(button, false);
                self.press_origins.insert(button, self.position);
            }
            Release { button } => {
                self.buttons.release(button);
                self.press_origins.remove(&button);
            }
        }
    }

    #[inline]
    pub fn end_frame(&mut self) {
        self.buttons.end_frame();
    }
}

#[derive(Debug, Default)]
pub struct KeyboardState {
    pub scancodes: ButtonInput<Scancode>,
    pub keycodes: ButtonInput<Keycode>,
    pub keymods: Keymods,
}

impl KeyboardState {
    #[inline]
    pub fn handle_event(&mut self, ev: KeyboardEvent) {
        use KeyboardEvent::*;
        match ev {
            Press {
                scancode,
                keycode,
                repeat,
            } => {
                self.scancodes.press(scancode, repeat);
                self.keycodes.press(keycode, repeat);
                if let Some(Keymods(keymods)) = Keymods::try_from_scancode(scancode) {
                    self.keymods.0 |= keymods;
                }
            }
            Release { scancode, keycode } => {
                self.scancodes.release(scancode);
                self.keycodes.release(keycode);
                if let Some(Keymods(keymods)) = Keymods::try_from_scancode(scancode) {
                    self.keymods.0 &= !keymods;
                }
            }
        }
    }

    #[inline]
    pub fn end_frame(&mut self) {
        self.scancodes.end_frame();
        self.keycodes.end_frame();
    }
}

#[derive(Debug, Clone)]
pub enum Event {
    Pointer(PointerEvent),
    Keyboard(KeyboardEvent),
}

#[derive(Debug, Default)]
pub struct State {
    pub pointer: PointerState,
    pub keyboard: KeyboardState,

    pub events: Vec<Event>,
}

impl State {
    #[inline]
    pub fn handle_event(&mut self, ev: Event) {
        use Event::*;
        match ev.clone() {
            Pointer(ev) => self.pointer.handle_event(ev),
            Keyboard(ev) => self.keyboard.handle_event(ev),
        }

        self.events.push(ev);
    }

    #[inline]
    pub fn end_frame(&mut self) {
        self.pointer.end_frame();
        self.keyboard.end_frame();

        self.events.clear();
    }
}
