use std::hash::{Hash, Hasher};

use nohash::{NoHash, NoHashMap, NoHashSet};

// pointer

#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PointerButton {
    /// equivalent to left mouse button
    Primary,
    /// equivalent to right mouse button
    Secondary,
    /// equivalent to middle mouse button
    Tertiary,
}

impl Hash for PointerButton {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_u8(*self as u8);
    }
}

impl NoHash for PointerButton {}

impl PointerButton {
    /// NOTE: this is useful for calling InputState's all_just_released method for example.
    pub fn all() -> [Self; 3] {
        use PointerButton::*;
        [Primary, Secondary, Tertiary]
    }
}

#[derive(Debug, Clone)]
pub enum PointerEvent {
    Motion { position: (f64, f64) },
    Press { button: PointerButton },
    Release { button: PointerButton },
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CursorShape {
    Default,
    Pointer,
    Text,
}

// keyboard

/// Scancode is a hardware-generated code that corresponds to the physical key pressed on the
/// keyboard. It represents the physical location of the key regardless of the keyboard layout.
/// Scancodes are consistent across different keyboard layouts and are generated by the keyboard
/// hardware itself. For example, pressing the key in the position of "Q" on a QWERTY keyboard will
/// generate the same scancode even if the keyboard layout is AZERTY or Dvorak
///
/// (c) ai
///
/// https://github.com/torvalds/linux/blob/231825b2e1ff6ba799c5eaf396d3ab2354e37c6b/include/uapi/linux/input-event-codes.h#L76
#[repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[rustfmt::skip]
pub enum Scancode {
    Reserved,               // KEY_RESERVED          0
    Esc,                    // KEY_ESC               1
    Num1,                   // KEY_1                 2
    Num2,                   // KEY_2                 3
    Num3,                   // KEY_3                 4
    Num4,                   // KEY_4                 5
    Num5,                   // KEY_5                 6
    Num6,                   // KEY_6                 7
    Num7,                   // KEY_7                 8
    Num8,                   // KEY_8                 9
    Num9,                   // KEY_9                 10
    Num0,                   // KEY_0                 11
    Minus,                  // KEY_MINUS             12
    Equal,                  // KEY_EQUAL             13
    Backspace,              // KEY_BACKSPACE         14
    Tab,                    // KEY_TAB               15
    Q,                      // KEY_Q                 16
    W,                      // KEY_W                 17
    E,                      // KEY_E                 18
    R,                      // KEY_R                 19
    T,                      // KEY_T                 20
    Y,                      // KEY_Y                 21
    U,                      // KEY_U                 22
    I,                      // KEY_I                 23
    O,                      // KEY_O                 24
    P,                      // KEY_P                 25
    BraceLeft,              // KEY_LEFTBRACE         26 /* [ */
    BraceRight,             // KEY_RIGHTBRACE        27 /* ] */
    Enter,                  // KEY_ENTER             28
    CtrlLeft,               // KEY_LEFTCTRL          29
    A,                      // KEY_A                 30
    S,                      // KEY_S                 31
    D,                      // KEY_D                 32
    F,                      // KEY_F                 33
    G,                      // KEY_G                 34
    H,                      // KEY_H                 35
    J,                      // KEY_J                 36
    K,                      // KEY_K                 37
    L,                      // KEY_L                 38
    Semicolon,              // KEY_SEMICOLON         39
    Apostrophe,             // KEY_APOSTROPHE        40
    Grave,                  // KEY_GRAVE             41
    ShiftLeft,              // KEY_LEFTSHIFT         42
    Backslash,              // KEY_BACKSLASH         43
    Z,                      // KEY_Z                 44
    X,                      // KEY_X                 45
    C,                      // KEY_C                 46
    V,                      // KEY_V                 47
    B,                      // KEY_B                 48
    N,                      // KEY_N                 49
    M,                      // KEY_M                 50
    Comma,                  // KEY_COMMA             51
    Dot,                    // KEY_DOT               52
    Slash,                  // KEY_SLASH             53
    ShiftRight,             // KEY_RIGHTSHIFT        54
    // KPAsterisk,          // KEY_KPASTERISK        55
    AltLeft,                // KEY_LEFTALT           56
    Space,                  // KEY_SPACE             57
    CapsLock,               // KEY_CAPSLOCK          58
    // F1,                  // KEY_F1                59
    // F2,                  // KEY_F2                60
    // F3,                  // KEY_F3                61
    // F4,                  // KEY_F4                62
    // F5,                  // KEY_F5                63
    // F6,                  // KEY_F6                64
    // F7,                  // KEY_F7                65
    // F8,                  // KEY_F8                66
    // F9,                  // KEY_F9                67
    // F10,                 // KEY_F10               68
    NumLock,                // KEY_NUMLOCK           69
    ScrollLock,             // KEY_SCROLLLOCK        70
    // KP7,                 // KEY_KP7               71
    // KP8,                 // KEY_KP8               72
    // KP9,                 // KEY_KP9               73
    // KPMinus,             // KEY_KPMINUS           74
    // KP4,                 // KEY_KP4               75
    // KP5,                 // KEY_KP5               76
    // KP6,                 // KEY_KP6               77
    // KPPlus,              // KEY_KPPLUS            78
    // KP1,                 // KEY_KP1               79
    // KP2,                 // KEY_KP2               80
    // KP3,                 // KEY_KP3               81
    // KP0,                 // KEY_KP0               82
    // KPDOT,               // KEY_KPDOT             83
    // _,
    // ZENKAKUHANKAKU,      // KEY_ZENKAKUHANKAKU    85
    // 102ND,               // KEY_102ND             86
    // F11,                 // KEY_F11               87
    // F12,                 // KEY_F12               88
    // RO,                  // KEY_RO                89
    // KATAKANA,            // KEY_KATAKANA          90
    // HIRAGANA,            // KEY_HIRAGANA          91
    // HENKAN,              // KEY_HENKAN            92
    // KATAKANAHIRAGANA,    // KEY_KATAKANAHIRAGANA  93
    // MUHENKAN,            // KEY_MUHENKAN          94
    // KPJPCOMMA,           // KEY_KPJPCOMMA         95
    // KPEnter,             // KEY_KPENTER           96
    CtrlRight,              // KEY_RIGHTCTRL         97
    // KPSlash,             // KEY_KPSLASH           98
    // SYSRQ,               // KEY_SYSRQ             99
    AltRight,               // KEY_RIGHTALT          100
    // LINEFEED,            // KEY_LINEFEED          101
    Home,                   // KEY_HOME              102
    ArrowUp,                // KEY_UP                103
    PageUp,                 // KEY_PAGEUP            104
    ArrowLeft,              // KEY_LEFT              105
    ArrowRight,             // KEY_RIGHT             106
    End,                    // KEY_END               107
    ArrowDown,              // KEY_DOWN              108
    PageDown,               // KEY_PAGEDOWN          109
    Insert,                 // KEY_INSERT            110
    Delete,                 // KEY_DELETE            111
    // MACRO,               // KEY_MACRO             112
    // MUTE,                // KEY_MUTE              113
    // VOLUMEDOWN,          // KEY_VOLUMEDOWN        114
    // VOLUMEUP,            // KEY_VOLUMEUP          115
    // POWER,               // KEY_POWER             116 /* SC System Power Down */
    // KPEqual,             // KEY_KPEQUAL           117
    // KPPLUSMINUS,         // KEY_KPPLUSMINUS       118
    // PAUSE,               // KEY_PAUSE             119
    // SCALE,               // KEY_SCALE             120 /* AL Compiz Scale (Expose) */
}

impl Hash for Scancode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        state.write_u32(*self as u32);
    }
}

impl NoHash for Scancode {}

/// Keycode is a code assigned by the operating system or software that represents the symbol or
/// character mapped to the key pressed, taking into account the current keyboard layout. For
/// example, pressing the same physical key might generate a different keycode on an AZERTY
/// keyboard compared to a QWERTY keyboard because the symbol mapped to that key differs
///
/// (c) ai
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Keycode {
    Char(char),
    Unhandled,
}

impl Hash for Keycode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            Self::Char(ch) => state.write_u32(*ch as u32),
            Self::Unhandled => {
                // NOTE: according to https://www.rfc-editor.org/rfc/rfc3629 In UTF-8, characters
                // from the U+0000..U+10FFFF. 0x10FFFF = 1114111 (21 bits)
                state.write_u32(u32::MAX)
            }
        }
    }
}

impl NoHash for Keycode {}

#[derive(Debug, Clone)]
pub enum KeyboardEvent {
    Press {
        scancode: Scancode,
        keycode: Keycode,
        /// true if this is a key repeat
        repeat: bool,
    },
    Release {
        scancode: Scancode,
        keycode: Keycode,
    },
}

// states

// NOTE: this is inspired by bevy (or stolen if you will). input handling is kind of nice there.
//
// NOTE: bevy also has just_pressed and just_released - those don't really do the thing because
// there can be a situation when key is pressed in a really quick succession with no frame in
// between -> this wil result in key-skip.
#[derive(Debug)]
pub struct ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    pressed: NoHashSet<B>,
    just_pressed: NoHashSet<B>,
    just_released: NoHashSet<B>,
}

impl<B> Default for ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    fn default() -> Self {
        Self {
            pressed: NoHashSet::default(),
            just_pressed: NoHashSet::default(),
            just_released: NoHashSet::default(),
        }
    }
}

impl<B> ButtonInput<B>
where
    B: Copy + Eq + NoHash,
{
    pub fn press(&mut self, button: B) {
        self.pressed.insert(button);
        self.just_pressed.insert(button);
    }

    pub fn release(&mut self, button: B) {
        self.pressed.remove(&button);
        self.just_released.insert(button);
    }

    pub fn clear_justs(&mut self) {
        self.just_pressed.clear();
        self.just_released.clear();
    }

    // pressed

    pub fn pressed(&self, button: B) -> bool {
        self.pressed.contains(&button)
    }

    pub fn any_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.pressed(button))
    }

    pub fn all_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.pressed(button))
    }

    pub fn iter_pressed(&self) -> impl Iterator<Item = B> {
        self.pressed.iter().copied()
    }

    // just pressed

    pub fn just_pressed(&self, button: B) -> bool {
        self.just_pressed.contains(&button)
    }

    pub fn any_just_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.just_pressed(button))
    }

    pub fn all_just_pressed(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.just_pressed(button))
    }

    pub fn iter_just_pressed(&self) -> impl Iterator<Item = B> {
        self.just_pressed.iter().copied()
    }

    // just released

    pub fn just_released(&self, button: B) -> bool {
        self.just_released.contains(&button)
    }

    pub fn any_just_released(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().any(|button| self.just_released(button))
    }

    pub fn all_just_released(&self, buttons: impl IntoIterator<Item = B>) -> bool {
        buttons.into_iter().all(|button| self.just_released(button))
    }

    pub fn iter_just_released(&self) -> impl Iterator<Item = B> {
        self.just_released.iter().copied()
    }
}

#[derive(Debug, Default)]
pub struct PointerState {
    pub position: (f64, f64),
    pub delta: (f64, f64),
    pub buttons: ButtonInput<PointerButton>,
    // NOTE: this is currently unused, but the plan is to use it for text selection / dragging.
    pub press_origins: NoHashMap<PointerButton, (f64, f64)>,
}

impl PointerState {
    #[inline]
    pub fn handle_event(&mut self, ev: PointerEvent) {
        use PointerEvent::*;
        match ev {
            Motion { position: next } => {
                let prev = self.position;
                self.delta = (next.0 - prev.0, next.1 - prev.1);
                self.position = next;
            }
            Press { button } => {
                self.buttons.press(button);
                self.press_origins.insert(button, self.position);
            }
            Release { button } => {
                self.buttons.release(button);
                self.press_origins.remove(&button);
            }
        }
    }

    #[inline]
    pub fn end_frame(&mut self) {
        self.buttons.clear_justs();
    }
}

#[derive(Debug, Default)]
pub struct KeyboardState {
    pub scancodes: ButtonInput<Scancode>,
    pub keycodes: ButtonInput<Keycode>,
}

impl KeyboardState {
    #[inline]
    pub fn handle_event(&mut self, ev: KeyboardEvent) {
        use KeyboardEvent::*;
        match ev {
            Press {
                scancode, keycode, ..
            } => {
                self.scancodes.press(scancode);
                self.keycodes.press(keycode);
            }
            Release { scancode, keycode } => {
                self.scancodes.release(scancode);
                self.keycodes.release(keycode);
            }
        }
    }

    #[inline]
    pub fn end_frame(&mut self) {
        self.scancodes.clear_justs();
        self.keycodes.clear_justs();
    }
}

#[derive(Debug, Clone)]
pub enum Event {
    Pointer(PointerEvent),
    Keyboard(KeyboardEvent),
}

#[derive(Debug, Default)]
pub struct State {
    pub pointer: PointerState,
    pub keyboard: KeyboardState,

    pub events: Vec<Event>,
}

impl State {
    #[inline]
    pub fn handle_event(&mut self, ev: Event) {
        use Event::*;
        match ev.clone() {
            Pointer(ev) => self.pointer.handle_event(ev),
            Keyboard(ev) => self.keyboard.handle_event(ev),
        }

        self.events.push(ev);
    }

    #[inline]
    pub fn end_frame(&mut self) {
        self.pointer.end_frame();
        self.keyboard.end_frame();

        self.events.clear();
    }
}
